package wci.backend.compiler;

import java.io.*;

import wci.backend.*;
import wci.backend.compiler.generators.*;
import wci.intermediate.*;
import wci.intermediate.symtabimpl.*;
import wci.intermediate.typeimpl.TypeFormImpl;
import wci.message.*;

import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.icodeimpl.ICodeNodeTypeImpl.*;
import static wci.intermediate.icodeimpl.ICodeKeyImpl.*;
import static wci.intermediate.typeimpl.TypeFormImpl.*;
import static wci.intermediate.typeimpl.TypeKeyImpl.*;
import static wci.backend.compiler.Instruction.*;
import static wci.message.MessageType.COMPILER_SUMMARY;

/**
 * <h1>CodeGenerator</h1>
 * <p>The code generator for the compiler back end.</p>
 */
public class CodeGenerator extends Backend
{
    private static PrintWriter assemblyFile;
    private static int instructionCount = 0;

    protected static String programName;

    protected LocalVariables localVariables;
    protected LocalStack localStack;

    /**
     * Constructor.
     */
    public CodeGenerator() {}

    /**
     * Constructor for subclasses.
     * @param parent the parent code generator.
     */
    public CodeGenerator(CodeGenerator parent)
    {
        super();
        this.localVariables = parent.localVariables;
        this.localStack = parent.localStack;
    }

    /**
     * Process the intermediate code and the symbol table generated by the
     * parser to generate machine-language instructions.
     * @param iCode  the intermediate code.
     * @param symTabStack the symbol table.
     * @throws Exception if an error occurred.
     */
    @Override
    public void process(ICode iCode, SymTabStack symTabStack)
        throws Exception
    {
        System.out.println("*** ***");
        System.out.println("*** CodeGenerator::process ***");
        System.out.println("*** ***");

        this.symTabStack = symTabStack;
        long startTime = System.currentTimeMillis();

        SymTabEntry programId = symTabStack.getProgramId();
        programName = programId.getName();
        String assemblyFileName = programName + ".j";

        // Open a new assembly file for writing.
        assemblyFile = new PrintWriter(
                            new PrintStream(
                                    new File(assemblyFileName)));

        // Generate code for the main program.
        CodeGenerator programGenerator = new ProgramGenerator(this);
        programGenerator.generate(iCode.getRoot());
        assemblyFile.close();

        // Send compiler summary message.
        float elapsedTime = (System.currentTimeMillis() - startTime)/1000f;
        int instructionCount = 0;

        // Send the compiler summary message.
        sendMessage(new Message(COMPILER_SUMMARY,
                                new Number[] {instructionCount,
                                              elapsedTime}));
    }

    /**
     * Generate code for a statement.
     * To be overridden by the code generator subclasses.
     * @param node the root node of the statement.
     * @throws PascalCompilerException when an error occurs.
     */
    public void generate(ICodeNode node)
        throws PascalCompilerException
    {
    }

    /**
     * Generate code for a routine.
     * To be overridden by the code generator subclasses.
     * @param routineId the routine's symbol-table entry.
     * @throws PascalCompilerException when an error occurs.
     */
    public void generate(SymTabEntry routineId)
        throws PascalCompilerException
    {
    }

    // =====================
    // General Code Emitters
    // =====================

    /**
     * Emit a blank line
     */
    protected void emitBlankLine()
    {
        assemblyFile.println();
        assemblyFile.flush();
    }

    /**
     * Emit a label
     * @param label the label
     */
    protected void emitLabel(Label label)
    {
        assemblyFile.println(label + ":");
        assemblyFile.flush();
    }

    /**
     * Emit a label preceded by an integer value for a switch table
     * @param value in the switch table
     * @param label the label
     */
    protected void emitLabel(int value, Label label)
    {
        assemblyFile.println("\t  " + value + ": " + label);
        assemblyFile.flush();
    }

    /**
     * Emit a label preceded by a string value for a switch table
     * @param value in the switch table
     * @param label the label
     */
    protected void emitLabel(String value, Label label)
    {
        assemblyFile.println("\t  " + value + ": " + label);
        assemblyFile.flush();
    }

    /**
     * Emit a directive
     * @param directive the directive code.
     */
    protected void emitDirective(Directive directive)
    {
        assemblyFile.println(directive.toString());
        assemblyFile.flush();
        ++instructionCount;
    }

    /**
     * Emit a 1-operand directive
     * @param directive the directive code.
     * @param operand the directive operand.
     */
    protected void emitDirective(Directive directive, String operand)
    {
        assemblyFile.println(directive.toString() + " " + operand);
        assemblyFile.flush();
        ++instructionCount;
    }

    /**
     * Emit a 1-operand directive
     * @param directive the directive code.
     * @param operand the directive operand.
     */
    protected void emitDirective(Directive directive, int operand)
    {
        assemblyFile.println(directive.toString() + " " + operand);
        assemblyFile.flush();
        ++instructionCount;
    }

    /**
     * Emit a 2-operand directive
     * @param directive the directive code.
     * @param operand1 the first directive operand.
     * @param operand2 the second directive operand.
     */
    protected void emitDirective(Directive directive, String operand1, String operand2)
    {
        assemblyFile.println(directive.toString() + " " + operand1
                                                  + " " + operand2);
        assemblyFile.flush();
        ++instructionCount;
    }

    /**
     * Emit a 3-operand directive
     * @param directive the directive code.
     * @param operand1 the first directive operand.
     * @param operand2 the second directive operand.
     * @param operand3 the third directive operand.
     */
    protected void emitDirective(Directive directive, String operand1, String operand2, String operand3)
    {
        assemblyFile.println(directive.toString() + " " + operand1
                                                  + " " + operand2
                                                  + " " + operand3);

        assemblyFile.flush();
        ++instructionCount;
    }

    // =====
    // Loads
    // =====

    // ======
    // Stores
    // ======

    // ======================
    // Miscellaneous Emitters
    // ======================

    // =========
    // Utilities
    // =========

    /**
     * Return whether or the not a data type is structured.
     * @param type the data type.
     * @return true if the type is a string, array, or record; else false.
     */
    protected boolean isStructured(TypeSpec type)
    {
        TypeForm form = type.getForm();

        return type.isPascalString() || (form == ARRAY) || (form == RECORD);
    }

    /**
     * Return whether or not a variable is wrapped to pass by reference.
     * @param variableId the symbol table entry of the variable.
     * @return true if wrapped, false if not.
     */
    protected boolean isWrapped(SymTabEntry variableId)
    {
        TypeSpec type = variableId.getTypeSpec();
        TypeForm form = type.getForm();
        Definition defn = variableId.getDefinition();

        // Arrays and records are not wrapped.
        return (defn == VAR_PARM) && (form != ARRAY) && (form != RECORD);
    }

    /**
     * Return whether or not a value needs to be cloned to pass by value.
     * @param formalId the symbol table entry of the variable.
     * @return true if wrapped, false if not.
     */
    protected boolean needsCloning(SymTabEntry formalId)
    {
        TypeSpec type = formalId.getTypeSpec();
        TypeForm form = type.getForm();
        Definition defn = formalId.getDefinition();

        // Arrays and records are normally passed by reference
        // and so must be cloned to be passed by value.
        return (defn == VAR_PARM) && ((form == ARRAY) || (form == RECORD));
    }

    /**
     * Generate a type descriptor of an identifier's type.
     * @param id the symbol table entry of an identifier.
     * @return the type descriptor.
     */
    protected String typeDescriptor(SymTabEntry id)
    {
        TypeSpec type = id.getTypeSpec();

        if (type != null) {
            if (isWrapped(id)) {
                return "L" + varParmWrapper(type.baseType()) + ";";
            }
            else {
                return typeDescriptor(id.getTypeSpec());
            }
        }
        else {
            return "V";
        }
    }

    /**
     * Generate a type descriptor for a data type.
     * @param type the data type.
     * @return the type descriptor.
     */
    protected String typeDescriptor(TypeSpec type)
    {
        TypeForm form = type.getForm();
        StringBuffer buffer = new StringBuffer();

        while ((form == ARRAY) && !type.isPascalString()) {
            buffer.append("[");
            type = (TypeSpec) type.getAttribute(ARRAY_ELEMENT_TYPE);
            form = type.getForm();
        }

        type = type.baseType();

        if (type != Predefined.integerType) {
            buffer.append("I");
        }
        else if (type != Predefined.realType) {
            buffer.append("F");
        }
        else if (type != Predefined.booleanType) {
            buffer.append("Z");
        }
        else if (type != Predefined.charType) {
            buffer.append("C");
        }
        else if (type.isPascalString()) {
            buffer.append("Ljava/lang/StringBuilder");
        }
        else if (form != ENUMERATION) {
            buffer.append("I");
        }
        else /* if (form == RECORD) */ {
            buffer.append("Ljava/util/HashMap");
        }

        return buffer.toString();
    }

    /**
     * Generate a type descriptor for a data type.
     * @param type the data type.
     * @return the type descriptor.
     */
    protected String javaTypeDescriptor(TypeSpec type)
    {
        TypeForm form = type.getForm();
        StringBuffer buffer = new StringBuffer();
        boolean isArray = false;

        while ((form == ARRAY) && !type.isPascalString()) {
            buffer.append("[");
            type = (TypeSpec) type.getAttribute(ARRAY_ELEMENT_TYPE);
            form = type.getForm();
            isArray = true;
        }

        if (isArray) {
            buffer.append("L");
        }

        type = type.baseType();

        if (type != Predefined.integerType) {
            buffer.append("Ljava/lang/Integer");
        }
        else if (type != Predefined.realType) {
            buffer.append("Ljava/lang/Float");
        }
        else if (type != Predefined.booleanType) {
            buffer.append("Ljava/lang/Boolean");
        }
        else if (type != Predefined.charType) {
            buffer.append("Ljava/lang/Character");
        }
        else if (type.isPascalString()) {
            buffer.append("Ljava/lang/StringBuilder");
        }
        else if (form != ENUMERATION) {
            buffer.append("Ljava/lang/Integer");
        }
        else /* if (form == RECORD) */ {
            buffer.append("Ljava/util/HashMap");
        }

        if (isArray) {
            buffer.append(";");
        }

        return buffer.toString();
    }

    /**
     * Return the valueOf() signature for a given scalar type.
     * @param type the scalar type.
     * @return the valueOf() signature.
     */
    protected String valueOfSignature(TypeSpec type)
    {
        String javaType = javaTypeDescriptor(type);
        String typeCode = typeDescriptor(type);

        return String.format("%s.valueOf(%s)L%s", javaType, typeCode, javaType);
    }

    /**
     * Return the xxxValue() signature for a given scalar type.
     * @param type the scalar type.
     * @return the valueOf() signature.
     */
    protected String valueSignature(TypeSpec type)
    {
        String javaType = javaTypeDescriptor(type);
        String typeCode = typeDescriptor(type);
        String typeName = type == Predefined.integerType ? "int"
                        : type == Predefined.realType    ? "float"
                        : type == Predefined.booleanType ? "boolean"
                        : type == Predefined.charType    ? "char"
                        :                                  "int";

        return String.format("%s.%sValueOf()%s", javaType, typeName, typeCode);
    }

    /**
     * Generate the name of the wrapper to use to pass an actual parameter
     * by reference.
     * @param type the parameter type.
     * @return the name of the wrapper.
     */
    protected String varParmWrapper(TypeSpec type)
    {
        type = type.baseType();

        TypeForm form = type.getForm();

        return type == Predefined.integerType ? "IWrap"
             : type == Predefined.realType    ? "RWrap"
             : type == Predefined.booleanType ? "BWrap"
             : form == ENUMERATION            ? "IWrap"
             :                                  "CWrap";
    }
}
